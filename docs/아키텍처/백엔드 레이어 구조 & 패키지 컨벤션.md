
# 백엔드 레이어 구조 & 패키지 컨벤션

전체 레이어 의존 방향(컴파일 기준)은 다음과 같다:

```text
api   →   core   ←   infra
```

- **api**: HTTP, 인증/인가, 요청/응답 변환
    
- **core**: 도메인 모델, 비즈니스 규칙, 유즈케이스(Service), Repository 인터페이스
    
- **infra**: DB, 외부 API, Redis, Elasticsearch 등 “구현체/어댑터” 계층
    

핵심 규칙:

- `api`는 **core만 의존**한다. (`infra` 직접 참조 금지)
    
- `infra`는 **core의 인터페이스를 구현**한다. (`api` 직접 참조 금지)
    
- `core`는 **api / infra 둘 다 몰라야 한다.**
    
    - DTO, Entity, Spring 어노테이션 등이 들어오면 안 됨.
        

---

## 1. API 레이어

패키지 예시:

```text
com.ssafy.sulmap.api
 ├─ controller
 ├─ dto
 │   ├─ request
 │   └─ response
 ├─ security
 ├─ config
 └─ utils
```

### 1.1 controller

**역할**

- `@RestController` 가 들어가는 HTTP 엔드포인트 계층
    
- Request DTO → Core Command/Query 변환
    
- Core Service 호출 → Result/Model → Response DTO 변환
    
- HTTP Status, 헤더, 쿠키, 세션 관리 등 **웹 레이어 책임**
    

**가이드라인**

- 비즈니스 로직(if/for로 규칙 만들기)은 최대한 core(Service)로 내린다.
    
- 예외/Result → HTTP 코드 변환 정도만 담당한다.
    

**예시**

```java
@RestController
@RequiredArgsConstructor
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    @PatchMapping("/me")
    public ResponseEntity<?> updateUser(
            @AuthenticationPrincipal LoginUserDetail userDetail,
            @Valid @RequestBody UpdateUserRequest req
    ) {
        var cmd = UpdateUserProfileCommand.builder()
                .userId(userDetail.getUserModel().getId())
                .name(req.name())
                .email(req.email())
                .phone(req.phone())
                .address(req.address())
                .birthday(req.birthday())
                .gender(UserGender.fromString(req.gender()))
                .profileImageUrl(req.profileImageUrl())
                .build();

        var result = userService.updateUserProfile(cmd);

        if (result.isFailure()) {
            return new ResponseEntity<>(result.getSingleErrorOrThrow().getStatus());
        }

        return ResponseEntity.ok(result.getOrThrow());
    }
}
```

---

### 1.2 dto

```text
api/dto/request   // 클라이언트 → 서버 (입력)
api/dto/response  // 서버 → 클라이언트 (출력)
```

#### request

- HTTP Body / PathVariable / QueryParam 을 담는 **입력용 DTO**
    
- **`record` 사용 추천** (불변 + 간결 + null-safe)
    
- `jakarta.validation` 으로 API 레벨 필수값 검증
    

```java
public record UpdateUserRequest(
    @NotBlank String name,
    @Email String email,
    String phone,
    String address,
    String birthday,
    String gender,
    String profileImageUrl
) {}
```

#### response

- API 응답 포맷 정의
    
- 프론트 요구사항에 맞는 필드만 노출
    
- 도메인 모델 전체를 그대로 노출하지 않고 필요한 정보만 선택
    

```java
public record GetUserResponse(
    Long id,
    String name,
    String email,
    String profileImageUrl
) {
    public static GetUserResponse fromModel(UserModel model) {
        return new GetUserResponse(
            model.getId(),
            model.getName(),
            model.getEmail(),
            model.getProfileImageUrl()
        );
    }
}
```

---

### 1.3 security

**역할**

- Spring Security 관련 설정 및 구성요소
    
    - `SecurityConfig`
        
    - `UserDetails`, `UserDetailsService`
        
    - 필터, 핸들러 등
        

**예시 구조**

```text
api/security
 ├─ SecurityConfig.java
 ├─ LoginUserDetail.java
 ├─ LoginUserDetailsService.java
 └─ filter / handler ...
```

**내용 예시**

- 세션/쿠키 기반 인증 설정
    
- `/login`, `/logout`, `/users/**` 권한 규칙
    
- `@AuthenticationPrincipal LoginUserDetail` 로 현재 로그인 유저 주입
    

---

### 1.4 config

**역할**

- API 레이어에서 사용하는 Spring 설정 모음
    
    - Swagger/OpenAPI 설정
        
    - CORS, MessageConverter, Locale 설정 등
        

**예시**

```text
api/config
 ├─ SwaggerConfig.java
 ├─ WebMvcConfig.java
 └─ AppConfig.java
```

---

### 1.5 utils

**역할**

- API 레이어에서만 사용하는 유틸리티 모음
    
    - Response wrapping
        
    - Servlet 요청/응답 관련 헬퍼
        
    - SecurityContext에서 로그인 유저 꺼내는 helper 등
        

**주의**

- 비즈니스 로직, DB 로직은 절대 넣지 않는다.
    
- core/infra에서 필요하면 해당 레이어 전용 유틸을 따로 만든다.
    

---

## 2. CORE 레이어

패키지 예시:

```text
com.ssafy.sulmap.core
 ├─ model
 │   ├─ command
 │   ├─ query
 │   └─ (domain)   // UserModel, BarModel 등
 ├─ enums
 ├─ repository
 └─ service
```

### 2.1 model/command

**역할**

- “쓰기/변경 계열” 유즈케이스의 입력 파라미터
    
- CRUD 기준으로 C, U, D 에 해당
    

**예시**

```java
// 회원 프로필 수정 Command
public record UpdateUserProfileCommand(
    Long userId,
    String name,
    String email,
    String phone,
    String address,
    Date birthday,
    UserGender gender,
    String profileImageUrl
) {}
```

특징:

- API Request DTO와 1:1일 필요는 없다.
    
- 도메인에 맞는 타입/enum을 사용한다.
    

---

### 2.2 model/query

**역할**

- “조회/검색 계열” 유즈케이스의 입력 조건
    
- 검색 조건, 필터, 페이징 정보를 모아둔 모델
    

**예시**

```java
public record SearchNearbyBarsQuery(
    double latitude,
    double longitude,
    int radiusMeters,
    int page,
    int size
) {}
```

---

### 2.3 Model (도메인 모델)

**역할**

- 핵심 비즈니스 개념을 표현하는 모델
    
    - 예: `UserModel`, `BarModel`, `VisitHistoryModel` 등
        
- 도메인 규칙을 메서드로 캡슐화
    

**규칙**

- JPA/MyBatis 어노테이션 X
    
- Spring 어노테이션 X
    
- 의미 있는 도메인 메서드를 제공 (`updateProfile`, `markDeleted` 등)
    

**예시**

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class UserModel {
    private Long id;
    private String loginId;
    private String passwordHash;
    private String name;
    private String email;
    private String phone;
    private String address;
    private Date birthday;
    private UserGender gender;
    private String profileImageUrl;
    private UserAuthProvider authProvider;
    private String providerId;
    private UserStatus status;
    private UserProfileVisitVisibility visitVisibilitySetting;
    private Date createdAt;
    private Date updatedAt;
    private Date deletedAt;
    private Date lastLoginAt;

    public void changeVisitVisibility(UserProfileVisitVisibility visibility) {
        this.visitVisibilitySetting = visibility;
    }

    public void markDeleted(Date now) {
        this.status = UserStatus.DELETED;
        this.deletedAt = now;
    }

    public void markLoggedIn(Date now) {
        this.lastLoginAt = now;
    }
}
```

---

### 2.4 enums

**역할**

- 도메인에서 사용하는 enum들을 모아두는 패키지
    
- DB/외부 입출력까지 고려한 변환 메서드 제공 추천
    

**예시**

```java
public enum UserGender {
    MALE, FEMALE, UNKNOWN;

    public static UserGender fromString(String value) {
        return Arrays.stream(values())
                     .filter(v -> v.name().equalsIgnoreCase(value))
                     .findFirst()
                     .orElse(UNKNOWN);
    }
}
```

```java
public enum UserAuthProvider {
    LOCAL, KAKAO, GOOGLE;

    public static UserAuthProvider fromValue(String value) {
        return Arrays.stream(values())
                     .filter(v -> v.name().equalsIgnoreCase(value))
                     .findFirst()
                     .orElse(LOCAL);
    }
}
```

---

### 2.5 repository (인터페이스)

**역할**

- 도메인/서비스에서 사용하는 저장소 추상화
    
- 구현은 infra 레이어에서 담당
    

**규칙**

- 메서드 시그니처는 **도메인 모델 / ID / Value Object**만 사용
    
- `UserEntity`, `UserMapper` 같은 infra 타입은 등장하면 안 된다.
    

**예시**

```java
public interface UserRepository {
    Long save(UserModel user); // insert or update
    Optional<UserModel> findById(long userId);
    Optional<UserModel> findByLoginId(String loginId);
}
```

---

### 2.6 service

**역할**

- 유즈케이스 구현 (비즈니스 규칙 + Repository 호출)
    
- API / 다른 서비스에서 호출하는 진입점
    

**인터페이스 예시**

```java
public interface UserService {
    Result<Long> updateUserProfile(UpdateUserProfileCommand command);
    Result<Void> softDeleteUser(long userId);
    Result<UserModel> findUserById(long userId);
    Result<UserModel> getUserProfileForViewer(long viewerUserId, long targetUserId);
}
```

**구현 예시**

```java
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    @Override
    public Result<Long> updateUserProfile(UpdateUserProfileCommand cmd) {
        var userOpt = userRepository.findById(cmd.userId());
        if (userOpt.isEmpty()) {
            return Result.fail(new NotFoundError("userId", cmd.userId()));
        }

        var user = userOpt.get();
        user.setName(cmd.name());
        user.setEmail(cmd.email());
        // TODO: 필요 시 도메인 메서드로 변경

        var savedId = userRepository.save(user);
        return Result.ok(savedId);
    }

    @Override
    public Result<UserModel> getUserProfileForViewer(long viewerUserId, long targetUserId) {
        var userOpt = userRepository.findById(targetUserId);
        if (userOpt.isEmpty()) {
            return Result.fail(new NotFoundError("userId", targetUserId));
        }

        var targetUser = userOpt.get();

        // 자기 자신은 항상 허용
        if (Objects.equals(viewerUserId, targetUser.getId())) {
            return Result.ok(targetUser);
        }

        // 프로필 공개 설정 검사 (PRIVATE 등)
        if (targetUser.getVisitVisibilitySetting() == UserProfileVisitVisibility.PRIVATE) {
            return Result.fail(new ForbiddenError("userId", targetUser.getId()));
        }

        return Result.ok(targetUser);
    }
}
```

---

## 3. INFRA 레이어

패키지 예시:

```text
com.ssafy.sulmap.infra
 ├─ external
 ├─ mapper
 ├─ model
 └─ repository
```

### 3.1 external

**역할**

- DB가 아닌 외부 시스템과 통신하는 어댑터
    
    - 외부 REST API
        
    - Redis
        
    - Kafka
        
    - Elasticsearch 등
        

**예시 구조**

```text
infra/external/kakao
 ├─ KakaoMapClient.java
 └─ KakaoMapResponseDto.java
```

---

### 3.2 mapper (MyBatis)

**역할**

- MyBatis에서 사용하는 Mapper 인터페이스
    
- SQL 호출을 담당 (XML or Annotation 기반)
    

**예시**

```java
@Mapper
public interface UserMapper {
    UserEntity selectById(long id);
    UserEntity selectByLoginId(String loginId);
    int insert(UserEntity user);
    int update(UserEntity user);
}
```

XML 예시:

```xml
<mapper namespace="com.ssafy.sulmap.infra.mapper.UserMapper">

    <resultMap id="UserResultMap" type="com.ssafy.sulmap.infra.model.UserEntity">
        <id property="id" column="id"/>
        <!-- 생략... -->
    </resultMap>

    <sql id="BaseColumns">
        id, login_id, password_hash, name, phone, email, birth_date, address, gender,
        profile_image_url, auth_provider, provider_id, status, visit_visibility_setting,
        last_login_at, created_at, updated_at, deleted_at
    </sql>

    <select id="selectById" parameterType="long" resultMap="UserResultMap">
        SELECT
        <include refid="BaseColumns"/>
        FROM users
        WHERE id = #{id}
          AND deleted_at IS NULL
    </select>

    <insert id="insert"
            parameterType="com.ssafy.sulmap.infra.model.UserEntity"
            useGeneratedKeys="true"
            keyProperty="id"
            keyColumn="id">
        INSERT INTO users (...)
        VALUES (...)
    </insert>

    <update id="update" parameterType="com.ssafy.sulmap.infra.model.UserEntity">
        UPDATE users
        <set>
            <!-- 필드들... -->
            updated_at = NOW()
        </set>
        WHERE id = #{id}
          AND deleted_at IS NULL
    </update>

</mapper>
```

---

### 3.3 model (Entity)

**역할**

- DB 테이블과 매핑되는 Entity / Record
    
- MyBatis Mapper와 함께 사용
    

**예시**

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {
    private Long id;
    private String loginId;
    private String passwordHash;
    private String name;
    private String email;
    private String phone;
    private String address;
    private Date birthday;
    private String gender;
    private String profileImageUrl;
    private String authProvider;
    private String providerId;
    private String status;
    private String visitVisibilitySetting;
    private Date createdAt;
    private Date updatedAt;
    private Date deletedAt;
    private Date lastLoginAt;

    public static UserEntity fromUserModel(UserModel userModel) {
        return UserEntity.builder()
                .id(userModel.getId())
                .loginId(userModel.getLoginId())
                .passwordHash(userModel.getPasswordHash())
                .name(userModel.getName())
                .email(userModel.getEmail())
                .phone(userModel.getPhone())
                .address(userModel.getAddress())
                .birthday(userModel.getBirthday())
                .gender(userModel.getGender().toString())
                .profileImageUrl(userModel.getProfileImageUrl())
                .authProvider(userModel.getAuthProvider().toString())
                .providerId(userModel.getProviderId())
                .status(userModel.getStatus().toString())
                .visitVisibilitySetting(userModel.getVisitVisibilitySetting().toString())
                .createdAt(userModel.getCreatedAt())
                .updatedAt(userModel.getUpdatedAt())
                .deletedAt(userModel.getDeletedAt())
                .lastLoginAt(userModel.getLastLoginAt())
                .build();
    }

    public UserModel toUserModel() {
        return UserModel.builder()
                .id(id)
                .loginId(loginId)
                .passwordHash(passwordHash)
                .name(name)
                .email(email)
                .phone(phone)
                .address(address)
                .birthday(birthday)
                .gender(UserGender.fromString(gender))
                .profileImageUrl(profileImageUrl)
                .authProvider(UserAuthProvider.fromValue(authProvider))
                .providerId(providerId)
                .status(UserStatus.fromString(status))
                .visitVisibilitySetting(UserProfileVisitVisibility.fromString(visitVisibilitySetting))
                .createdAt(createdAt)
                .updatedAt(updatedAt)
                .deletedAt(deletedAt)
                .lastLoginAt(lastLoginAt)
                .build();
    }
}
```

---

### 3.4 repository (구현체)

**역할**

- core `Repository` 인터페이스들의 구현체
    
- Entity ↔ Model 변환 + Mapper 호출 담당
    

**예시**

```java
@Repository
@RequiredArgsConstructor
public class UserRepositoryImpl implements UserRepository {
    private final UserMapper userMapper;

    @Override
    @Transactional
    public Long save(UserModel user) {
        var entity = UserEntity.fromUserModel(user);

        if (user.getId() == null) {
            userMapper.insert(entity);    // PK가 entity.id 에 세팅됨
        } else {
            userMapper.update(entity);
        }

        return entity.getId();
    }

    @Override
    public Optional<UserModel> findById(long userId) {
        UserEntity entity = userMapper.selectById(userId);
        return Optional.ofNullable(entity).map(UserEntity::toUserModel);
    }

    @Override
    public Optional<UserModel> findByLoginId(String userLoginId) {
        UserEntity entity = userMapper.selectByLoginId(userLoginId);
        return Optional.ofNullable(entity).map(UserEntity::toUserModel);
    }
}
```

---

## 4. 새 기능 추가 시 추천 작업 순서

1. **도메인/유즈케이스 설계 (core)**
    
    - 어떤 도메인 모델이 필요한지 (`User`, `Bar`, `VisitHistory` 등)
        
    - Command / Query / Service 메서드 시그니처 정의
        
2. **Repository 인터페이스(core) 정의/수정**
    
    - 도메인이 필요로 하는 저장/조회 메서드 설계
        
3. **infra 구현**
    
    - Entity, Mapper(MyBatis XML), RepositoryImpl 구현
        
    - Entity ↔ Model 매핑
        
4. **api 구현**
    
    - Request/Response DTO 설계
        
    - Controller 추가/수정
        
    - Security 설정이 필요하면 security/config 수정
        

---

## 5. 네이밍 컨벤션 요약

- Controller: `XxxController`
    
- Request DTO: `XxxRequest`
    
- Response DTO: `XxxResponse`
    
- Command: `XxxCommand`
    
- Query: `XxxQuery`
    
- 도메인 모델: `UserModel`, `BarModel`, `VisitHistoryModel` …
    
- Repository 인터페이스(core): `XxxRepository`
    
- Repository 구현체(infra): `XxxRepositoryImpl`
    
- Entity(infra): `XxxEntity`
    
- 외부 API Client(infra/external): `XxxClient`
    